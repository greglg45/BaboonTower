using UnityEngine;
using System.Collections.Generic;
using BaboonTower.Game;

/// <summary>
/// Visualise le chemin généré et permet de débugger la génération
/// </summary>
public class PathDebugVisualizer : MonoBehaviour
{
    [Header("Visualization")]
    [SerializeField] private bool showPath = true;
    [SerializeField] private bool showWaypoints = true;
    [SerializeField] private bool showGrid = false;
    [SerializeField] private bool showTurns = true;
    
    [Header("Path Info")]
    [SerializeField] private int pathLength = 0;
    [SerializeField] private int turnCount = 0;
    [SerializeField] private string currentMap = "";
    
    [Header("Colors")]
    [SerializeField] private Color pathColor = Color.yellow;
    [SerializeField] private Color turnColor = Color.red;
    [SerializeField] private Color waypointColor = Color.cyan;
    [SerializeField] private Color gridColor = new Color(0.5f, 0.5f, 0.5f, 0.3f);
    
    private MapManagerV2 mapManager;
    private MapGenerator mapGenerator;
    private List<Vector3> worldPath;
    private List<int> turnIndices;
    
    private void Start()
    {
        mapManager = GetComponent<MapManagerV2>();
        mapGenerator = GetComponent<MapGenerator>();
        
        if (mapManager == null)
        {
            Debug.LogError("[PathDebugVisualizer] MapManagerV2 not found!");
        }
        
        // S'abonner aux événements de génération
        if (mapGenerator != null)
        {
            mapGenerator.OnPathGenerated += OnPathGenerated;
        }
    }
    
    private void OnDestroy()
    {
        if (mapGenerator != null)
        {
            mapGenerator.OnPathGenerated -= OnPathGenerated;
        }
    }
    
    private void OnPathGenerated(List<Vector2Int> path)
    {
        if (path == null || path.Count == 0)
        {
            Debug.Log("[PathDebugVisualizer] No path generated");
            return;
        }
        
        pathLength = path.Count;
        
        // Convertir en positions monde
        worldPath = new List<Vector3>();
        foreach (var pos in path)
        {
            worldPath.Add(mapManager.GridToWorldPosition(pos));
        }
        
        // Identifier les virages
        IdentifyTurns(path);
        
        Debug.Log($"[PathDebugVisualizer] Path analyzed: {pathLength} tiles, {turnCount} turns");
    }
    
    private void IdentifyTurns(List<Vector2Int> path)
    {
        turnIndices = new List<int>();
        turnCount = 0;
        
        if (path.Count < 3) return;
        
        Vector2Int lastDirection = Vector2Int.zero;
        
        for (int i = 1; i < path.Count; i++)
        {
            Vector2Int currentDirection = path[i] - path[i - 1];
            
            if (i > 1 && currentDirection != lastDirection)
            {
                turnIndices.Add(i - 1);
                turnCount++;
            }
            
            lastDirection = currentDirection;
        }
    }
    
    private void Update()
    {
        // Raccourcis pour activer/désactiver les visualisations
        if (Input.GetKeyDown(KeyCode.P))
        {
            showPath = !showPath;
            Debug.Log($"[PathDebugVisualizer] Show path: {showPath}");
        }
        
        if (Input.GetKeyDown(KeyCode.G))
        {
            showGrid = !showGrid;
            Debug.Log($"[PathDebugVisualizer] Show grid: {showGrid}");
        }
        
        if (Input.GetKeyDown(KeyCode.T))
        {
            showTurns = !showTurns;
            Debug.Log($"[PathDebugVisualizer] Show turns: {showTurns}");
        }
        
        // Forcer une régénération avec différentes seeds
        if (Input.GetKeyDown(KeyCode.R))
        {
            RegenerateWithNewSeed();
        }
    }
    
    private void RegenerateWithNewSeed()
    {
        if (mapGenerator == null) return;
        
        // Changer la seed de manière aléatoire
        System.Reflection.FieldInfo configField = mapGenerator.GetType().GetField(
            "currentMapConfig", 
            System.Reflection.BindingFlags.NonPublic | System.Reflection.BindingFlags.Instance
        );
        
        if (configField != null)
        {
            MapConfig config = (MapConfig)configField.GetValue(mapGenerator);
            if (config != null)
            {
                int oldSeed = config.seed;
                config.seed = Random.Range(1000, 9999);
                Debug.Log($"[PathDebugVisualizer] Regenerating with new seed: {oldSeed} -> {config.seed}");
                
                mapGenerator.GenerateMap();
            }
        }
    }
    
    private void OnDrawGizmos()
    {
        // Dessiner la grille
        if (showGrid && mapManager != null)
        {
            Gizmos.color = gridColor;
            
            for (int x = 0; x <= 30; x++)
            {
                Vector3 start = new Vector3(x, 0, 0);
                Vector3 end = new Vector3(x, 16, 0);
                Gizmos.DrawLine(start, end);
            }
            
            for (int y = 0; y <= 16; y++)
            {
                Vector3 start = new Vector3(0, y, 0);
                Vector3 end = new Vector3(30, y, 0);
                Gizmos.DrawLine(start, end);
            }
        }
        
        // Dessiner le chemin
        if (showPath && worldPath != null && worldPath.Count > 1)
        {
            Gizmos.color = pathColor;
            
            for (int i = 0; i < worldPath.Count - 1; i++)
            {
                Vector3 start = worldPath[i];
                Vector3 end = worldPath[i + 1];
                
                // Ligne plus épaisse pour le chemin
                DrawThickLine(start, end, 0.2f);
            }
        }
        
        // Dessiner les waypoints
        if (showWaypoints && worldPath != null)
        {
            Gizmos.color = waypointColor;
            
            for (int i = 0; i < worldPath.Count; i++)
            {
                // Premier et dernier waypoint plus gros
                if (i == 0 || i == worldPath.Count - 1)
                {
                    Gizmos.DrawWireSphere(worldPath[i], 0.4f);
                }
                else
                {
                    Gizmos.DrawWireSphere(worldPath[i], 0.15f);
                }
            }
        }
        
        // Marquer les virages
        if (showTurns && worldPath != null && turnIndices != null)
        {
            Gizmos.color = turnColor;
            
            foreach (int index in turnIndices)
            {
                if (index < worldPath.Count)
                {
                    Gizmos.DrawWireSphere(worldPath[index], 0.3f);
                    Gizmos.DrawWireCube(worldPath[index], Vector3.one * 0.4f);
                }
            }
        }
    }
    
    private void DrawThickLine(Vector3 start, Vector3 end, float thickness)
    {
        Gizmos.DrawLine(start, end);
        
        // Dessiner des lignes parallèles pour donner de l'épaisseur
        Vector3 offset = Vector3.Cross(end - start, Vector3.forward).normalized * thickness;
        Gizmos.DrawLine(start + offset, end + offset);
        Gizmos.DrawLine(start - offset, end - offset);
    }
    
    private void OnGUI()
    {
        if (!showPath) return;
        
        // Afficher les infos du chemin
        GUI.Box(new Rect(10, 280, 250, 140), "Path Debug Info");
        GUI.Label(new Rect(20, 300, 230, 20), $"Path Length: {pathLength} tiles");
        GUI.Label(new Rect(20, 320, 230, 20), $"Turns: {turnCount}");
        GUI.Label(new Rect(20, 340, 230, 20), $"Map: {currentMap}");
        GUI.Label(new Rect(20, 360, 230, 20), "Controls:");
        GUI.Label(new Rect(20, 380, 230, 20), "P: Toggle Path");
        GUI.Label(new Rect(20, 400, 230, 20), "G: Toggle Grid");
        GUI.Label(new Rect(20, 420, 230, 20), "T: Toggle Turns");
        GUI.Label(new Rect(20, 440, 230, 20), "R: New Random Seed");
    }
}