using UnityEngine;
using System.Collections.Generic;
using System.IO;

namespace BaboonTower.Game
{
    /// <summary>
    /// Version améliorée du MapManager avec génération procédurale
    /// Remplace l'ancien MapManager.cs
    /// </summary>
    public class MapManagerV2 : MonoBehaviour
    {
        [Header("Map Configuration")]
        [SerializeField] private Vector2Int mapSize = new Vector2Int(30, 16);
        [SerializeField] private float tileSize = 1f;
        
        [Header("Visual Prefabs")]
        [SerializeField] private GameObject tilePrefab; // Prefab de base pour une tuile
        [SerializeField] private Material pathMaterial;
        [SerializeField] private Material borderMaterial;
        [SerializeField] private Material groundMaterial;
        [SerializeField] private Material spawnMaterial;
        [SerializeField] private Material castleMaterial;
        
        [Header("Decoration Prefabs")]
        [SerializeField] private GameObject treePrefab;
        [SerializeField] private GameObject rockPrefab;
        [SerializeField] private GameObject bushPrefab;
        
        [Header("Generation")]
        [SerializeField] private bool useProceduralGeneration = true;
        [SerializeField] private bool autoGenerateOnStart = true;
        
        // Composants
        private MapGenerator generator;
        private TileType[,] mapGrid;
        private GameObject[,] tileObjects;
        private List<Vector3> worldPath;
        
        // Propriétés publiques pour compatibilité avec l'ancien système
        public Vector2Int MapSize => mapSize;
        public Vector2Int SpawnPos { get; private set; }
        public Vector2Int CastlePos { get; private set; }
        public List<Vector3> WorldPath => worldPath;
        
        // Events
        public System.Action OnMapReady;
        
        private void Awake()
        {
            // Créer ou récupérer le générateur
            generator = GetComponent<MapGenerator>();
            if (generator == null && useProceduralGeneration)
            {
                generator = gameObject.AddComponent<MapGenerator>();
            }
            
            // S'abonner aux events du générateur
            if (generator != null)
            {
                generator.OnMapGenerated += OnMapGenerated;
                generator.OnPathGenerated += OnPathGenerated;
            }
            
            // Initialiser les tableaux
            tileObjects = new GameObject[mapSize.x, mapSize.y];
            worldPath = new List<Vector3>();
        }
        
        private void Start()
        {
            if (autoGenerateOnStart)
            {
                InitializeMap();
            }
            
            SetupCamera();
        }
        
        /// <summary>
        /// Initialise la map (génération ou manuelle)
        /// </summary>
        public void InitializeMap()
        {
            if (useProceduralGeneration && generator != null)
            {
                // Générer la map procéduralement
                generator.GenerateMap();
            }
            else
            {
                // Utiliser l'ancienne méthode manuelle (compatibilité)
                CreateManualMap();
            }
        }
        
        /// <summary>
        /// Callback quand la map est générée
        /// </summary>
        private void OnMapGenerated(TileType[,] grid)
        {
            mapGrid = grid;
            mapSize = new Vector2Int(grid.GetLength(0), grid.GetLength(1));
            
            // Nettoyer l'ancienne map si elle existe
            ClearMap();
            
            // Créer les tuiles visuelles
            CreateVisualMap();
            
            // Informer que la map est prête
            OnMapReady?.Invoke();
        }
        
        /// <summary>
        /// Callback quand le chemin est généré
        /// </summary>
        private void OnPathGenerated(List<Vector2Int> path)
        {
            if (path == null || path.Count < 2) return;
            
            // Définir spawn et château
            SpawnPos = path[0];
            CastlePos = path[path.Count - 1];
            
            // Convertir en positions monde
            worldPath.Clear();
            foreach (var pos in path)
            {
                worldPath.Add(GridToWorldPosition(pos));
            }
        }
        
        /// <summary>
        /// Crée la représentation visuelle de la map
        /// </summary>
        private void CreateVisualMap()
        {
            GameObject tilesContainer = new GameObject("MapTiles");
            tilesContainer.transform.SetParent(transform);
            
            GameObject decorContainer = new GameObject("Decorations");
            decorContainer.transform.SetParent(transform);
            
            for (int x = 0; x < mapSize.x; x++)
            {
                for (int y = 0; y < mapSize.y; y++)
                {
                    Vector2Int gridPos = new Vector2Int(x, y);
                    TileType tileType = mapGrid[x, y];
                    
                    // Créer la tuile visuelle
                    GameObject tile = CreateTileVisual(gridPos, tileType, tilesContainer.transform);
                    tileObjects[x, y] = tile;
                    
                    // Ajouter les décorations si nécessaire
                    if (tileType == TileType.Decoration)
                    {
                        CreateDecoration(gridPos, decorContainer.transform);
                    }
                }
            }
            
            // Créer les visuels spéciaux pour spawn et château
            CreateSpecialVisuals();
        }
        
        /// <summary>
        /// Crée une tuile visuelle
        /// </summary>
        private GameObject CreateTileVisual(Vector2Int gridPos, TileType type, Transform parent)
        {
            GameObject tile;
            
            // Utiliser un prefab ou créer un quad
            if (tilePrefab != null)
            {
                tile = Instantiate(tilePrefab, parent);
            }
            else
            {
                tile = GameObject.CreatePrimitive(PrimitiveType.Quad);
                tile.transform.SetParent(parent);
            }
            
            tile.name = $"Tile_{gridPos.x}_{gridPos.y}_{type}";
            
            // Position
            Vector3 worldPos = GridToWorldPosition(gridPos);
            tile.transform.position = worldPos;
            tile.transform.rotation = Quaternion.identity;
            tile.transform.localScale = Vector3.one * tileSize * 0.95f;
            
            // Matériau selon le type
            Renderer renderer = tile.GetComponent<Renderer>();
            if (renderer != null)
            {
                Material mat = GetMaterialForTileType(type);
                if (mat != null)
                {
                    renderer.material = mat;
                }
                else
                {
                    // Fallback avec couleurs
                    renderer.material = new Material(Shader.Find("Sprites/Default"));
                    renderer.material.color = GetColorForTileType(type);
                }
                
                renderer.sortingOrder = GetSortingOrderForTileType(type);
            }
            
            // Enlever le collider pour les performances (sauf pour les tuiles interactives)
            Collider col = tile.GetComponent<Collider>();
            if (col != null && type != TileType.Empty && type != TileType.Border)
            {
                Destroy(col);
            }
            
            return tile;
        }
        
        /// <summary>
        /// Crée une décoration
        /// </summary>
        private void CreateDecoration(Vector2Int gridPos, Transform parent)
        {
            GameObject decoration = null;
            
            // Choisir aléatoirement le type de décoration
            float rand = Random.value;
            
            if (rand < 0.4f && treePrefab != null)
            {
                decoration = Instantiate(treePrefab, parent);
            }
            else if (rand < 0.7f && rockPrefab != null)
            {
                decoration = Instantiate(rockPrefab, parent);
            }
            else if (bushPrefab != null)
            {
                decoration = Instantiate(bushPrefab, parent);
            }
            else
            {
                // Fallback: créer un cube simple
                decoration = GameObject.CreatePrimitive(PrimitiveType.Cube);
                decoration.transform.SetParent(parent);
                decoration.transform.localScale = Vector3.one * tileSize * 0.6f;
                
                Renderer renderer = decoration.GetComponent<Renderer>();
                if (renderer != null)
                {
                    renderer.material = new Material(Shader.Find("Sprites/Default"));
                    renderer.material.color = new Color(0.2f, 0.5f, 0.2f); // Vert foncé
                }
            }
            
            if (decoration != null)
            {
                decoration.name = $"Decoration_{gridPos.x}_{gridPos.y}";
                Vector3 worldPos = GridToWorldPosition(gridPos);
                worldPos.z = -0.5f; // Légèrement devant les tuiles
                decoration.transform.position = worldPos;
            }
        }
        
        /// <summary>
        /// Crée les visuels pour spawn et château
        /// </summary>
        private void CreateSpecialVisuals()
        {
            // Spawn
            if (SpawnPos != null)
            {
                GameObject spawn = GameObject.CreatePrimitive(PrimitiveType.Quad);
                spawn.name = "SpawnPoint";
                spawn.transform.SetParent(transform);
                spawn.transform.position = GridToWorldPosition(SpawnPos) + Vector3.back * 0.2f;
                spawn.transform.rotation = Quaternion.identity;
                spawn.transform.localScale = Vector3.one * tileSize * 1.5f;
                
                Renderer spawnRenderer = spawn.GetComponent<Renderer>();
                if (spawnMaterial != null)
                {
                    spawnRenderer.material = spawnMaterial;
                }
                else
                {
                    spawnRenderer.material = new Material(Shader.Find("Sprites/Default"));
                    spawnRenderer.material.color = new Color(0f, 1f, 0f, 0.8f);
                }
                
                // Texte
                CreateTextMesh(spawn.transform, "SPAWN", Vector3.back * 0.1f);
            }
            
            // Château
            if (CastlePos != null)
            {
                GameObject castle = GameObject.CreatePrimitive(PrimitiveType.Quad);
                castle.name = "Castle";
                castle.transform.SetParent(transform);
                castle.transform.position = GridToWorldPosition(CastlePos) + Vector3.back * 0.2f;
                castle.transform.rotation = Quaternion.identity;
                castle.transform.localScale = new Vector3(tileSize * 2f, tileSize * 2f, 1f);
                
                Renderer castleRenderer = castle.GetComponent<Renderer>();
                if (castleMaterial != null)
                {
                    castleRenderer.material = castleMaterial;
                }
                else
                {
                    castleRenderer.material = new Material(Shader.Find("Sprites/Default"));
                    castleRenderer.material.color = new Color(0.2f, 0.3f, 0.8f, 0.9f);
                }
                
                // Texte
                CreateTextMesh(castle.transform, "CASTLE", Vector3.back * 0.1f);
            }
        }
        
        /// <summary>
        /// Crée un texte 3D
        /// </summary>
        private void CreateTextMesh(Transform parent, string text, Vector3 localPos)
        {
            GameObject textObj = new GameObject($"Text_{text}");
            textObj.transform.SetParent(parent);
            textObj.transform.localPosition = localPos;
            
            TextMesh textMesh = textObj.AddComponent<TextMesh>();
            textMesh.text = text;
            textMesh.fontSize = 24;
            textMesh.color = Color.white;
            textMesh.alignment = TextAlignment.Center;
            textMesh.anchor = TextAnchor.MiddleCenter;
            textObj.transform.localScale = Vector3.one * 0.05f;
        }
        
        /// <summary>
        /// Obtient le matériau pour un type de tuile
        /// </summary>
        private Material GetMaterialForTileType(TileType type)
        {
            switch (type)
            {
                case TileType.Path:
                    return pathMaterial;
                case TileType.Border:
                    return borderMaterial;
                case TileType.Spawn:
                    return spawnMaterial;
                case TileType.Castle:
                    return castleMaterial;
                default:
                    return groundMaterial;
            }
        }
        
        /// <summary>
        /// Obtient la couleur pour un type de tuile (fallback)
        /// </summary>
        private Color GetColorForTileType(TileType type)
        {
            switch (type)
            {
                case TileType.Path:
                    return new Color(0.6f, 0.4f, 0.2f); // Marron
                case TileType.Border:
                    return new Color(0.3f, 0.5f, 0.3f); // Vert foncé
                case TileType.Spawn:
                    return Color.green;
                case TileType.Castle:
                    return Color.blue;
                case TileType.Decoration:
                    return new Color(0.2f, 0.4f, 0.2f); // Vert très foncé
                default:
                    return new Color(0.4f, 0.6f, 0.4f); // Vert clair
            }
        }
        
        /// <summary>
        /// Obtient l'ordre de tri pour un type de tuile
        /// </summary>
        private int GetSortingOrderForTileType(TileType type)
        {
            switch (type)
            {
                case TileType.Path:
                    return 1;
                case TileType.Border:
                    return 0;
                case TileType.Spawn:
                case TileType.Castle:
                    return 3;
                case TileType.Decoration:
                    return 2;
                default:
                    return 0;
            }
        }
        
        /// <summary>
        /// Nettoie la map existante
        /// </summary>
        private void ClearMap()
        {
            // Détruire tous les objets enfants
            for (int i = transform.childCount - 1; i >= 0; i--)
            {
                DestroyImmediate(transform.GetChild(i).gameObject);
            }
            
            // Réinitialiser les tableaux
            if (tileObjects != null)
            {
                for (int x = 0; x < tileObjects.GetLength(0); x++)
                {
                    for (int y = 0; y < tileObjects.GetLength(1); y++)
                    {
                        if (tileObjects[x, y] != null)
                        {
                            DestroyImmediate(tileObjects[x, y]);
                        }
                    }
                }
            }
        }
        
        /// <summary>
        /// Configure la caméra pour voir toute la map
        /// </summary>
        private void SetupCamera()
        {
            Camera mainCamera = Camera.main;
            if (mainCamera != null)
            {
                float centerX = mapSize.x * tileSize / 2f;
                float centerY = mapSize.y * tileSize / 2f;
                mainCamera.transform.position = new Vector3(centerX, centerY, -10f);
                
                mainCamera.orthographic = true;
                mainCamera.orthographicSize = Mathf.Max(
                    mapSize.x * tileSize / 2f / mainCamera.aspect, 
                    mapSize.y * tileSize / 2f
                );
                
                mainCamera.transform.rotation = Quaternion.identity;
                mainCamera.backgroundColor = new Color(0.1f, 0.15f, 0.1f);
            }
        }
        
        /// <summary>
        /// Crée une map manuelle simple (fallback pour compatibilité)
        /// </summary>
        private void CreateManualMap()
        {
            // Implémentation similaire à l'ancien MapManager
            // Pour compatibilité avec l'ancien système
            
            SpawnPos = new Vector2Int(0, mapSize.y / 2);
            CastlePos = new Vector2Int(mapSize.x - 1, mapSize.y / 2);
            
            mapGrid = new TileType[mapSize.x, mapSize.y];
            
            // Créer un chemin simple horizontal
            for (int x = 0; x < mapSize.x; x++)
            {
                mapGrid[x, mapSize.y / 2] = TileType.Path;
            }
            
            // Ajouter les bordures
            for (int x = 0; x < mapSize.x; x++)
            {
                if (mapSize.y / 2 - 1 >= 0)
                    mapGrid[x, mapSize.y / 2 - 1] = TileType.Border;
                if (mapSize.y / 2 + 1 < mapSize.y)
                    mapGrid[x, mapSize.y / 2 + 1] = TileType.Border;
            }
            
            mapGrid[SpawnPos.x, SpawnPos.y] = TileType.Spawn;
            mapGrid[CastlePos.x, CastlePos.y] = TileType.Castle;
            
            // Créer le chemin monde
            worldPath.Clear();
            worldPath.Add(GridToWorldPosition(SpawnPos));
            worldPath.Add(GridToWorldPosition(CastlePos));
            
            CreateVisualMap();
            OnMapReady?.Invoke();
        }
        
        #region Public Methods (Compatibilité avec l'ancien système)
        
        /// <summary>
        /// Convertit une position de grille en position monde
        /// </summary>
        public Vector3 GridToWorldPosition(Vector2Int gridPos)
        {
            return new Vector3(
                gridPos.x * tileSize + tileSize * 0.5f,
                gridPos.y * tileSize + tileSize * 0.5f,
                0f
            );
        }
        
        /// <summary>
        /// Convertit une position monde en position de grille
        /// </summary>
        public Vector2Int WorldToGridPosition(Vector3 worldPos)
        {
            return new Vector2Int(
                Mathf.FloorToInt(worldPos.x / tileSize),
                Mathf.FloorToInt(worldPos.y / tileSize)
            );
        }
        
        /// <summary>
        /// Vérifie si une tour peut être placée à cette position
        /// </summary>
        public bool CanPlaceTowerAt(Vector2Int gridPos)
        {
            if (generator != null)
            {
                return generator.CanPlaceTowerAt(gridPos);
            }
            
            // Fallback pour l'ancien système
            if (gridPos.x < 0 || gridPos.x >= mapSize.x ||
                gridPos.y < 0 || gridPos.y >= mapSize.y)
                return false;
            
            TileType tile = mapGrid[gridPos.x, gridPos.y];
            return tile == TileType.Empty || tile == TileType.Border;
        }
        
        /// <summary>
        /// Met en surbrillance une tuile (pour preview de placement)
        /// </summary>
        public void HighlightTile(Vector2Int gridPos, bool canPlace)
        {
            if (gridPos.x >= 0 && gridPos.x < mapSize.x &&
                gridPos.y >= 0 && gridPos.y < mapSize.y)
            {
                GameObject tile = tileObjects[gridPos.x, gridPos.y];
                if (tile != null)
                {
                    Renderer renderer = tile.GetComponent<Renderer>();
                    if (renderer != null)
                    {
                        Color highlightColor = canPlace ?
                            new Color(0.2f, 1f, 0.2f, 0.8f) :
                            new Color(1f, 0.2f, 0.2f, 0.8f);
                        renderer.material.color = highlightColor;
                    }
                }
            }
        }
        
        /// <summary>
        /// Réinitialise la couleur d'une tuile
        /// </summary>
        public void ResetTileHighlight(Vector2Int gridPos)
        {
            if (gridPos.x >= 0 && gridPos.x < mapSize.x &&
                gridPos.y >= 0 && gridPos.y < mapSize.y)
            {
                GameObject tile = tileObjects[gridPos.x, gridPos.y];
                if (tile != null)
                {
                    Renderer renderer = tile.GetComponent<Renderer>();
                    if (renderer != null)
                    {
                        TileType type = mapGrid[gridPos.x, gridPos.y];
                        renderer.material.color = GetColorForTileType(type);
                    }
                }
            }
        }
        
        #endregion
        
        #region Editor Methods
        
        [ContextMenu("Generate New Map")]
        public void GenerateNewMap()
        {
            if (generator != null)
            {
                generator.GenerateMap();
            }
            else
            {
                Debug.LogError("Map Generator component not found!");
            }
        }
        
        [ContextMenu("Save Current Map")]
        public void SaveCurrentMap()
        {
            if (generator != null)
            {
                generator.SaveGeneratedMap();
            }
        }
        
        [ContextMenu("Clear Map")]
        public void EditorClearMap()
        {
            ClearMap();
        }
        
        #endregion
    }
}